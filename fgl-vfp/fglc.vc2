*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.21" SourceFile="fglc.vcx" CPID="1251" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS fglc_activeobj AS fglc_obj OF "fglc.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: actpointsshow
		*m: addactpoint
		*m: delactpoint
		*m: getactpoint
		*m: hlinktestlocal_access
		*m: hlinktestlocal_assign
		*m: hlinktestremote_access
		*m: hlinktestremote_assign
		*m: islinked
		*m: link
		*m: linkaccept
		*m: linkapply
		*m: linkcollide
		*m: linktest
		*m: movelinked
		*m: nactpoints
		*m: unlink
		*p: allowmovelinked
		*p: hlinktestlocal
		*p: hlinktestremote
	*</DefinedPropArrayMethod>

	PROTECTED allowmovelinked
	*<PropValue>
		allowmovelinked = .F.
		hlinktestlocal = 0
		hlinktestremote = 0
		Name = "fglc_activeobj"
	*</PropValue>
	
	PROCEDURE actpointsshow
		LPARAMETERS tlVisible
		
		This.oNodeActPoints.isVisible = m.tlVisible
		
	ENDPROC

	PROCEDURE addactpoint
		LPARAMETERS toActPoint
		
		IF VARTYPE(m.toActPoint)<>"O"
			RETURN .F.
		ENDIF
		
		IF EMPTY(toActPoint.oNode.fgl_name)=.T.
			RETURN .F.
		ENDIF
		
		IF This.oNodeActPoints.aChilds.find(toActPoint.oNode.hFGL)<>-1
			RETURN .F.
		ENDIF
		
		This.oNodeActPoints.aChilds.add(m.toActPoint.oNode.hFGL)
		*!*	This.oMain.oActPointsCollider.aNodes.add(m.toActPoint.oNode.hFGL)
		
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE delactpoint
		LPARAMETERS tcName
		
		IF EMPTY(m.tcName) 
			RETURN .F.
		ENDIF
		
		LOCAL lhActPoint
		lhActPoint = This.oNodeActPoints.find(m.tcName)
		IF lhActPoint=0
			RETURN .F.
		ENDIF
		
		LOCAL loActPoint
		lhActPoint = This.oMain.getHandler(lhActPoint, @loActPoint)
		IF VARTYPE(loActPoint)="O"
			loActPoint.fglc_release(lhActPoint)
		ENDIF
		This.oNodeActPoints.aChilds.del(lhActPoint)
		
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE Destroy
		DODEFAULT()
		
		
	ENDPROC

	PROCEDURE fglc_bind
		LPARAMETERS thNode
		
		DODEFAULT(m.thNode)
		This.oNodeActPoints.hFGL=(This.oNode.find("actPoints"))
		
	ENDPROC

	PROCEDURE fglc_create
		IF DODEFAULT()=.F.
			RETURN .F.
		ENDIF
		
		This.oMain.oActPointsCollider.aNodes.add(This.oNodeActPoints.aChilds.hFGL)
		
	ENDPROC

	PROCEDURE fglc_define
		DODEFAULT()
		
		This.NewObject("oNodeActPoints", "fgl.fglNode")
		
		This.oNodeActPoints.fgl_create(This.hScene())
		This.oNodeActPoints.fgl_name = "actPoints"
		This.oNode.aChilds.add(This.oNodeActPoints.hFGL)
		
		This.hLinkTestLocal =  0
		This.hLinkTestRemote = 0
		
	ENDPROC

	PROCEDURE fglc_release
		LPARAMETERS thNode
		
		This.fglc_bind(m.thNode)
		This.unlink()
		
		IF VARTYPE(This.oMain)="O"
			LOCAL i, lnActPoints, lhActPoint, loActPoint, lhSaveActPoint
			lnActPoints = This.nActPoints()
			FOR i=1 TO lnActPoints
				lhActPoint = This.oMain.getHandler(This.oNodeActPoints.aChilds.get(0), @loActPoint)
				IF EMPTY(lhActPoint)=.F.
					lhSaveActPoint = loActPoint.hNode()
					loActPoint.fglc_release(lhActPoint)
					loActPoint.fglc_bind(lhSaveActPoint)
				ENDIF
			ENDFOR
		ENDIF
		
		This.oNodeActPoints.fgl_release()
		
		DODEFAULT(m.thNode)
		
	ENDPROC

	PROCEDURE getactpoint
		LPARAMETERS tcName
		
		IF VARTYPE(m.tcName)="N"
			RETURN This.oNodeActPoints.aChilds.get(m.tcName)
		ENDIF
		
		IF EMPTY(m.tcName) 
			RETURN 0
		ENDIF
		
		RETURN This.oNodeActPoints.find(m.tcName)
		
	ENDPROC

	HIDDEN PROCEDURE hlinktestlocal_access
		RETURN NVL(This.oNode.getProp("hLinkTestLocal"), 0)
		
	ENDPROC

	HIDDEN PROCEDURE hlinktestlocal_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("hLinkTestLocal", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE hlinktestremote_access
		RETURN NVL(This.oNode.getProp("hLinkTestRemote"), 0)
	ENDPROC

	HIDDEN PROCEDURE hlinktestremote_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("hLinkTestRemote", m.vNewVal)
		
	ENDPROC

	PROCEDURE islinked
		
		LOCAL i, lhNode, loNode, lnPoints
		loNode = This.oMain.oNode
		lnPoints = This.oNodeActPoints.aChilds.size()
		FOR i=1 TO lnPoints 
			loNode.hFGL=(This.oNodeActPoints.aChilds.get(i-1))
			IF EMPTY(NVL(loNode.getProp("linkedTo"),0))=.F.
				RETURN .T.
			ENDIF
		ENDFOR
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE link
		LPARAMETERS toCollider
		
		LOCAL loCollider, loCollideInfo
		loCollider = IIF(VARTYPE(m.toCollider)="O", m.toCollider, This.oMain.oActPointsCollider)
		loCollideInfo = This.oMain.oCollideInfo
		
		LOCAL i, lnNodes, lhNode, lhNode1, lhNode2, loActPoint, lhSaveActPoint
		lnNodes = This.oNodeActPoints.aChilds.size()
		lhNode1 = 0
		lhNode2 = 0
		FOR i=1 TO lnNodes
			lhNode = This.oNodeActPoints.aChilds.get(i-1)
			loCollider.testNode(lhNode, loCollideInfo.hFGL)
			lhNode1 = loCollideInfo.hNode1
			lhNode2 = loCollideInfo.hNode2
			IF This.linkAccept(lhNode1, lhNode2)=.F.
				LOOP
			ENDIF
			This.oMain.getHandler(lhNode1, @loActPoint)
			IF VARTYPE(loActPoint)="O"
				lhSaveActPoint = loActPoint.hNode()
				loActPoint.fglc_bind(lhNode1)
				loActPoint.linkedTo = lhNode2
				loActPoint.fglc_bind(lhSaveActPoint)
			ENDIF
		
			This.oMain.getHandler(lhNode2, @loActPoint)
			IF VARTYPE(loActPoint)="O"
				lhSaveActPoint = loActPoint.hNode()
				loActPoint.fglc_bind(lhNode2)
				loActPoint.linkedTo = lhNode1
				loActPoint.fglc_bind(lhSaveActPoint)
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE linkaccept
		LPARAMETERS thNode1, thNode2
		
		IF EMPTY(m.thNode1) OR EMPTY(m.thNode2)
			RETURN .F.
		ENDIF
		LOCAL loActPoint, lcPointType1, lcPointType2,  lhSaveActPoint, lhParent1, lhParent2
		loActPoint = This.oMain.oNode
		
		loActPoint.hFGL=(m.thNode1)
		lhParent1 = loActPoint.hParent
		lcPointType1 = NVL(loActPoint.getProp("pointType"),"")
		IF EMPTY(NVL(loActPoint.getProp("linkedTo"),0))=.F.
			RETURN .F.
		ENDIF
		
		loActPoint.hFGL=(m.thNode2)
		lhParent2 = loActPoint.hParent
		lcPointType2 = NVL(loActPoint.getProp("pointType"),"")
		IF EMPTY(NVL(loActPoint.getProp("linkedTo"),0))=.F.
			RETURN .F.
		ENDIF
		
		IF (lcPointType1 == lcPointType2)=.F.
			RETURN .F.
		ENDIF
		
		IF (lhParent1 = lhParent2)
			RETURN .F.
		ENDIF
		
		
		RETURN .T.
		
	ENDPROC

	PROCEDURE linkapply
		LPARAMETERS thActPointLocal, thActPointRemote
		
		LOCAL loActPoint, lhSaveActPoint
		
		IF EMPTY(m.thActPointLocal)=.F.
			IF This.oMain.getHandler(m.thActPointLocal, @loActPoint)=m.thActPointLocal
				IF VARTYPE(loActPoint)="O"
					lhSaveActPoint = loActPoint.hNode()
					loActPoint.fglc_bind(m.thActPointLocal)
					IF loActPoint.isLinked()=.F.
						loActPoint.showLinked(.F.)
					ENDIF
					loActPoint.fglc_bind(lhSaveActPoint)
				ENDIF
			ENDIF
		ENDIF
		
		IF EMPTY(m.thActPointRemote)=.F.
			IF This.oMain.getHandler(m.thActPointRemote, @loActPoint)=m.thActPointRemote
				IF VARTYPE(loActPoint)="O"
					lhSaveActPoint = loActPoint.hNode()
					loActPoint.fglc_bind(m.thActPointRemote)
					IF loActPoint.isLinked()=.F.
						loActPoint.showLinked(.F.)
					ENDIF
					loActPoint.fglc_bind(lhSaveActPoint)
				ENDIF
			ENDIF
		ENDIF
		
		This.link()
		
		This.move(0,0,0)
		
	ENDPROC

	PROCEDURE linkcollide
		LPARAMETERS toCollider, thNodeFound1, thNodeFound2
		
		LOCAL loCollider, loCollideInfo
		loCollider = IIF(VARTYPE(m.toCollider)="O", m.toCollider, This.oMain.oActPointsCollider)
		loCollideInfo = This.oMain.oCollideInfo
		
		LOCAL i, lnNodes, lhNode, lhNode1, lhNode2, llRes
		lnNodes = This.oNodeActPoints.aChilds.size()
		lhNode1 = 0
		lhNode2 = 0
		llRes = .F.
		FOR i=1 TO lnNodes
			lhNode = This.oNodeActPoints.aChilds.get(i-1)
			loCollider.testNode(lhNode, loCollideInfo.hFGL)
			lhNode1 = loCollideInfo.hNode1
			lhNode2 = loCollideInfo.hNode2
			IF This.linkAccept(lhNode1, lhNode2)
				llRes = .T.
				EXIT
			ENDIF
		ENDFOR
		
		IF llRes=.F.
			thNodeFound1 = 0
			thNodeFound2 = 0
			RETURN .F.
		ELSE
			thNodeFound1 = lhNode1
			thNodeFound2 = lhNode2
			RETURN .T.
		ENDIF
		
		
	ENDPROC

	PROCEDURE linktest
		LPARAMETERS toCollider
		
		LOCAL loActPoint, lhLinkTestLocal, lhLinkTestRemote, lhNode1, lhNode2, lhSaveActPoint
		lhLinkTestLocal = This.hLinkTestLocal 
		lhLinkTestRemote = This.hLinkTestRemote
		lhNode1 = 0
		lhNode2 = 0
		
		This.linkCollide(m.toCollider, @lhNode1, @lhNode2)
		
		IF lhLinkTestLocal <> lhNode1
			IF EMPTY(lhLinkTestLocal)=.F.
				IF This.oMain.getHandler(lhLinkTestLocal, @loActPoint)=lhLinkTestLocal
					IF VARTYPE(loActPoint)="O"
						lhSaveActPoint = loActPoint.hNode()
						loActPoint.fglc_bind(lhLinkTestLocal)
						loActPoint.showLinked(.F.)
						loActPoint.fglc_bind(lhSaveActPoint)
					ENDIF
				ENDIF
			ENDIF
			IF EMPTY(lhNode1)=.F.
				IF This.oMain.getHandler(lhNode1, @loActPoint)=lhNode1
					IF VARTYPE(loActPoint)="O"
						lhSaveActPoint = loActPoint.hNode()
						loActPoint.fglc_bind(lhNode1)
						loActPoint.showLinked(.T.)
						loActPoint.fglc_bind(lhSaveActPoint)
					ENDIF
				ENDIF
			ENDIF
			This.hLinkTestLocal = lhNode1
		ENDIF
		
		IF lhLinkTestRemote <> lhNode2
			IF EMPTY(lhLinkTestRemote)=.F.
				IF This.oMain.getHandler(lhLinkTestRemote, @loActPoint)=lhLinkTestRemote
					IF VARTYPE(loActPoint)="O"
						lhSaveActPoint = loActPoint.hNode()
						loActPoint.fglc_bind(lhLinkTestRemote)
						loActPoint.showLinked(.F.)
						loActPoint.fglc_bind(lhSaveActPoint)
					ENDIF
				ENDIF
			ENDIF
			IF EMPTY(lhNode2)=.F.	
				IF This.oMain.getHandler(lhNode2, @loActPoint)=lhNode2 
					IF VARTYPE(loActPoint)="O"
						lhSaveActPoint = loActPoint.hNode()
						loActPoint.fglc_bind(lhNode2)
						loActPoint.showLinked(.T.)
						loActPoint.fglc_bind(lhSaveActPoint)
					ENDIF
				ENDIF
			ENDIF
			This.hLinkTestRemote = lhNode2
		ENDIF
		
	ENDPROC

	PROCEDURE mousemove
		LPARAMETERS nButton, nShift, oPickInfo
		
		LOCAL llRes
		This.allowMoveLinked=IIF(m.nShift=1, .T., .F.)
		llRes = DODEFAULT(m.nButton, m.nShift, m.oPickInfo)
		This.allowMoveLinked=.F.
		RETURN llRes
		
	ENDPROC

	PROCEDURE move
		LPARAMETERS tnX, tnY, tnZ
		
		DODEFAULT(m.tnX, m.tnY, m.tnZ)
		
		IF EMPTY(EVL(EVL(m.tnX, m.tnY), m.tnZ))=.F. AND This.allowMoveLinked
			This.moveLinked()
		ELSE
			IF EMPTY(EVL(EVL(m.tnX,m.tnY),m.tnZ))=.F.
				This.unlink()
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE movelinked
		
		This.oMain.lockEvents(.T.)
		********************************************
		
		LOCAL lnX, lnY, lnZ
		
		LOCAL i, lnActPoints, lhActPoint, lhActPointRemote
		
		LOCAL liStack, liPoint, loObj, lhNext, lhSaveObj, loPos
		liStack = 0
		liPoint = 1
		loObj = This
		lhNext = 0
		lhSaveObj = loObj.hNode()
		loPos = This.oMain.oVector1
		LOCAL ARRAY laStack(100,2)
		
		LOCAL lcPoints
		lcPoints = ","
		
		DO WHILE .T.
			lnActPoints = loObj.nActPoints()
			lhNext = 0
			FOR i=liPoint TO lnActPoints
				lhActPoint = loObj.getActPoint(i-1)
				IF ATC(","+TRANSFORM(lhActPoint)+",",lcPoints)<>0
					LOOP
				ENDIF
				lcPoints = lcPoints + TRANSFORM(lhActPoint)+","
				WITH This.oMain.oNode
					.hFGL=(lhActPoint)
					lhActPointRemote = NVL(.getProp("linkedTo"),0)
					IF EMPTY(lhActPointRemote)=.T.
						LOOP
					ENDIF
					.getPos(loPos, .T.)
					lnX = loPos.x
					lnY = loPos.y
					lnZ = loPos.z
		
					lcPoints = lcPoints + TRANSFORM(lhActPointRemote)+","
				ENDWITH
				
				WITH This.oMain.oNode
					.hFGL=(lhActPointRemote)
					.getPos(loPos, .T.)
					lnX = lnX - loPos.x 
					lnY = lnY - loPos.y
					lnZ = lnZ - loPos.z
		
					.hFGL=(.hParent)
					lhNext = .hParent
				ENDWITH
				
				IF EMPTY(lhNext)=.F.
					liStack = liStack + 1
					IF liStack>ALEN(laStack,1)
						DIMENSION laStack(liStack*2, ALEN(laStack,2))
					ENDIF
					laStack[liStack,1]=loObj.hNode()
					laStack[liStack,2]=i
					
					loObj.fglc_bind(lhNext)
					loObj.oNode.moveBy(lnX, lnY, lnZ)
					liPoint = 1
					EXIT
				ELSE
					LOOP
				ENDIF
			ENDFOR
			IF liStack<>0 
				IF EMPTY(lhNext)
					loObj.fglc_bind(laStack[liStack,1])
					liPoint = laStack[liStack,2]+1
					liStack = liStack - 1
				ENDIF
			ELSE
				EXIT
			ENDIF
		ENDDO
		loObj.fglc_bind(lhSaveObj)
		
		********************************************
		This.oMain.lockEvents(.F.)
		
	ENDPROC

	PROCEDURE nactpoints
		RETURN This.oNodeActPoints.aChilds.size()
		
	ENDPROC

	PROCEDURE unlink
		
		IF VARTYPE(This.oMain)<>"O" &&on form destroy
			RETURN .F.
		ENDIF
		
		This.hLinkTestLocal = 0
		This.hLinkTestRemote = 0
		
		LOCAL i, lnNodes, lhNode, loActPoint, lhSaveActPoint
		lnNodes = This.oNodeActPoints.aChilds.size()
		FOR i=1 TO lnNodes
			lhNode = This.oNodeActPoints.aChilds.get(i-1)
			IF This.oMain.getHandler(lhNode, @loActPoint)=lhNode
				IF VARTYPE(loActPoint)="O"
					lhSaveActPoint = loActPoint.hNode()
					loActPoint.fglc_bind(lhNode)
					loActPoint.linkedTo = 0
					loActPoint.fglc_bind(lhSaveActPoint)
				ENDIF
			ENDIF
		ENDFOR
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fglc_actpoint AS fglc_obj OF "fglc.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: islinked
		*m: linkedto_access
		*m: linkedto_assign
		*m: nmovemode_access
		*m: nmovemode_assign
		*m: nresizemode_access
		*m: nresizemode_assign
		*m: pointtype_access
		*m: pointtype_assign
		*m: showlinked
		*p: linkedto
		*p: nmovemode		&& 0 - move itself, 1 - move parent
		*p: nresizemode
		*p: pointtype
	*</DefinedPropArrayMethod>

	*<PropValue>
		linkedto = 0
		Name = "fglc_actpoint"
		nmovemode = 0
		nresizemode = 0
		pointtype = ("")
	*</PropValue>
	
	PROCEDURE fglc_define
		DODEFAULT()
		
		This.linkedTo = 0
		This.pointType = ""
		This.nMoveMode = 0
		This.nResizeMode = 0
		
	ENDPROC

	PROCEDURE islinked
		RETURN EMPTY(This.linkedTo)=.F.
		
	ENDPROC

	HIDDEN PROCEDURE linkedto_access
		RETURN NVL(This.oNode.getProp("linkedTo"), 0)
		
	ENDPROC

	HIDDEN PROCEDURE linkedto_assign
		LPARAMETERS vNewVal
		
		LOCAL lhActPoint, lhActPointRemotePrev
		lhActPoint = This.hNode()
		lhActPointRemotePrev = EVL(NVL(This.oNode.getProp("linkedTo"),0),0)
		This.oNode.setProp("linkedTo", m.vNewVal)
		This.showLinked(EMPTY(m.vNewVal)=.F.)
		
		IF lhActPointRemotePrev<>lhActPoint AND EMPTY(lhActPointRemotePrev)=.F. 
			LOCAL loActPoint, lhSaveBind
			IF This.oMain.getHandler(lhActPointRemotePrev, @loActPoint)=lhActPointRemotePrev
				lhSaveBind = loActPoint.hNode()
				loActPoint.fglc_bind(lhActPointRemotePrev)
				loActPoint.oNode.setProp("linkedTo", 0)
				loActPoint.showLinked(.F.)
				loActPoint.fglc_bind(lhSaveBind)
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE move
		LPARAMETERS tnX, tnY, tnZ
		
		LOCAL loParent, lhParent, lhSaveParent
		lhParent = This.oMain.getHandler(This.oNode.hParent, @loParent)
		IF EMPTY(lhParent)
			RETURN
		ENDIF
		lhSaveParent = loParent.hNode()
		loParent.fglc_bind(lhParent)
		
		This.oMain.lockEvents(.T.)
		**********************************************
		
		LOCAL lnPx, lnPy, lnPz
		This.oNode.getPos(This.oMain.oVector1)
		lnPx = This.oMain.oVector1.x
		lnPy = This.oMain.oVector1.y
		lnPz = This.oMain.oVector1.z
		
		DODEFAULT(m.tnX, m.tnY, m.tnZ)
		
		This.oNode.getPos(This.oMain.oVector1)
		lnPx = This.oMain.oVector1.x - lnPx
		lnPy = This.oMain.oVector1.y - lnPy
		lnPz = This.oMain.oVector1.z - lnPz
		
		
		IF EMPTY(EVL(EVL(lnPx, lnPy), lnPz))=.T.
			loParent.fglc_bind(lhSaveParent)
			This.oMain.lockEvents(.F.)
			RETURN
		ENDIF
		
		IF This.isLinked()=.T.
			This.linkedTo = 0
		ENDIF
		
		IF EMPTY(This.nResizeMode)=.F. 
			LOCAL lnSizeX, lnSizeY, lnSizeZ
			loParent.oNode.getBoundsExt(0,0,This.oMain.oVector1)
			lnSizeX=This.oMain.oVector1.x
			lnSizeY=This.oMain.oVector1.y
			lnSizeZ=This.oMain.oVector1.z
		
			DO CASE
			 CASE This.nResizeMode=1
			  WITH loParent
				IF lnSizeX-lnPx < .minSizeX
					lnPx = lnSizeX - .minSizeX
				ELSE
					IF lnSizeX-lnPx > .maxSizeX
						lnPx = .maxSizeX - lnSizeX
					ENDIF
				ENDIF
				IF lnSizeY-lnPy < .minSizeY
					lnPy = lnSizeY - .minSizeY
				ELSE
					IF lnSizeY-lnPy > .maxSizeY
						lnPy = .maxSizeY - lnSizeY
					ENDIF
				ENDIF
				IF lnSizeZ-lnPz < .minSizeZ
					lnPz = lnSizeZ - .minSizeZ
				ELSE
					IF lnSizeZ-lnPz >.maxSizeZ
						lnPz = .maxSizeZ - lnSizeZ
					ENDIF
				ENDIF
		
				.oNode.moveDir(lnPx, lnPy, lnPz)
				.oNode.correctBoundsExt(0,0,0, -lnPx, -lnPy, -lnPz)
			  ENDWITH
			 CASE This.nResizeMode=2
			  WITH loParent
				IF lnSizeX+lnPx < .minSizeX
					lnPx = -(lnSizeX - .minSizeX)
				ELSE
					IF lnSizeX+lnPx > .maxSizeX
						lnPx = - (.maxSizeX - lnSizeX)
					ENDIF
				ENDIF
				IF lnSizeY+lnPy < .minSizeY
					lnPy = - (lnSizeY - .minSizeY)
				ELSE
					IF lnSizeY+lnPy > .maxSizeY
						lnPy = -(.maxSizeY - lnSizeY)
					ENDIF
				ENDIF
				IF lnSizeZ+lnPz < .minSizeZ
					lnPz = -(lnSizeZ - .minSizeZ)
				ELSE
					IF lnSizeZ+lnPz > .maxSizeZ
						lnPz = -(.maxSizeZ - lnSizeZ)
					ENDIF
				ENDIF
		
				.oNode.correctBoundsExt(0,0,0, lnPx, lnPy, lnPz)
		 	  ENDWITH
			ENDCASE
			loParent.resize()
		ELSE
			IF This.nMoveMode=1
				DODEFAULT(-tnX, -tnY, -tnZ)
				loParent.move(lnPx, lnPy, lnPz)
			ENDIF
		ENDIF
		
		loParent.fglc_bind(lhSaveParent)
		**********************************************
		This.oMain.lockEvents(.F.)
		
	ENDPROC

	HIDDEN PROCEDURE nmovemode_access
		RETURN NVL(This.oNode.getProp("nMoveMode"),0)
		
	ENDPROC

	HIDDEN PROCEDURE nmovemode_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("nMoveMode",m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE nresizemode_access
		RETURN NVL(This.oNode.getProp("nResizeMode"),0)
		
	ENDPROC

	HIDDEN PROCEDURE nresizemode_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("nResizeMode",m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE pointtype_access
		RETURN NVL(This.oNode.getProp("pointType"), "")
	ENDPROC

	HIDDEN PROCEDURE pointtype_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("pointType", m.vNewVal)
		
	ENDPROC

	PROCEDURE showlinked
		LPARAMETERS tlIsLinked
		
		IF m.tlIsLinked
			This.oNode.bbox.meshColor = RGB(0,255,0)
			This.oNode.bbox.meshLineWidth = 5
			This.oNode.bbox.isVisible = .T.
		ELSE
			This.oNode.bbox.isVisible = .F.
			IF This.isSelected
				This.showSelected(.T.)
			ENDIF	
		ENDIF
		
	ENDPROC

	PROCEDURE showselected
		LPARAMETERS tlIsSelected
		
		This.oNode.bbox.meshColor = RGB(255,255,255)
		This.oNode.bbox.meshLineWidth = 5
		DODEFAULT(m.tlIsSelected)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fglc_main AS fglc_viewport OF "fglc.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oGetHandler" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oModel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oScene" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oLight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oNode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oMaterial" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oMesh" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oActPointsCollider" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oCollideInfo" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oJoint" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oCollider" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oShader" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oShaderProg" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oVisual" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oCollection" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oVector1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oVector2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oQuat1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oQuat2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oVector3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oQuat3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="o3DRect1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="o3DRect2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="o3DRect3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oRow41" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oRow42" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oRow43" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oVector4" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: errmsg
		*m: gethandler
		*m: loadmodel
		*m: lockevents
		*m: unloadmodel
		*p: amodels
		*p: hactpointscolliderinit
		*p: hcollideinfoinit
		*p: hsceneinit
		*p: lockeventslevel
		*p: msaamode
		*a: lockeventsstate[1,10]
	*</DefinedPropArrayMethod>

	HIDDEN amodels,hactpointscolliderinit,hcollideinfoinit,hsceneinit,lockeventslevel,lockeventsstate
	*<PropValue>
		amodels = 
		fglc_class = ("fglc_main")
		hactpointscolliderinit = 0
		hcollideinfoinit = 0
		Height = 297
		hsceneinit = 0
		lockeventslevel = 0
		msaamode = 0
		Name = "fglc_main"
		Width = 639
		oViewport.Name = "oViewport"
		oCam.Name = "oCam"
		oPickInfo.Name = "oPickInfo"
	*</PropValue>

	ADD OBJECT 'o3DRect1' AS fgl3drect WITH ;
		Height = 2, ;
		Left = 24, ;
		Name = "o3DRect1", ;
		Top = -136, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'o3DRect2' AS fgl3drect WITH ;
		Height = 2, ;
		Left = 24, ;
		Name = "o3DRect2", ;
		Top = -112, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'o3DRect3' AS fgl3drect WITH ;
		Height = 2, ;
		Left = 24, ;
		Name = "o3DRect3", ;
		Top = -88, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oActPointsCollider' AS fglcollider WITH ;
		Height = 1, ;
		Left = 228, ;
		Name = "oActPointsCollider", ;
		Top = -84, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oCollection' AS fglcollection WITH ;
		Height = 2, ;
		Left = 36, ;
		Name = "oCollection", ;
		Top = -234, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oCollideInfo' AS fglcollideinfo WITH ;
		Height = 1, ;
		Left = 192, ;
		Name = "oCollideInfo", ;
		Top = -84, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oCollider' AS fglcollider WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oCollider", ;
		Top = -114, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oGetHandler' AS fglnode WITH ;
		Height = 0, ;
		Left = 60, ;
		Name = "oGetHandler", ;
		Top = -24, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oJoint' AS fgljoint WITH ;
		Height = 2, ;
		Left = 36, ;
		Name = "oJoint", ;
		Top = -186, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oLight' AS fgllight WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oLight", ;
		Top = -210, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oMaterial' AS fglmaterial WITH ;
		Height = 2, ;
		Left = 48, ;
		Name = "oMaterial", ;
		Top = -276, ;
		Width = 23
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oMesh' AS fglmesh WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oMesh", ;
		Top = -162, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oModel' AS fglmodel WITH ;
		Height = 0, ;
		Left = 12, ;
		Name = "oModel", ;
		Top = -12, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oNode' AS fglnode WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oNode", ;
		Top = -186, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oQuat1' AS fglquat WITH ;
		Height = 2, ;
		Left = 168, ;
		Name = "oQuat1", ;
		Top = -172, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oQuat2' AS fglquat WITH ;
		Height = 2, ;
		Left = 168, ;
		Name = "oQuat2", ;
		Top = -136, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oQuat3' AS fglquat WITH ;
		Height = 2, ;
		Left = 168, ;
		Name = "oQuat3", ;
		Top = -100, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oRow41' AS fglrow4 WITH ;
		Height = 2, ;
		Left = 140, ;
		Name = "oRow41", ;
		Top = -61, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oRow42' AS fglrow4 WITH ;
		Height = 2, ;
		Left = 156, ;
		Name = "oRow42", ;
		Top = -59, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oRow43' AS fglrow4 WITH ;
		Height = 2, ;
		Left = 180, ;
		Name = "oRow43", ;
		Top = -59, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oScene' AS fglscene WITH ;
		Height = 0, ;
		Left = 12, ;
		Name = "oScene", ;
		Top = -12, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oShader' AS fglshader WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oShader", ;
		Top = -90, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oShaderProg' AS fglshaderprog WITH ;
		Height = 2, ;
		Left = 48, ;
		Name = "oShaderProg", ;
		Top = -90, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oText' AS fgltext WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oText", ;
		Top = -234, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oVector1' AS fglvector WITH ;
		Height = 2, ;
		Left = 144, ;
		Name = "oVector1", ;
		Top = -172, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oVector2' AS fglvector WITH ;
		Height = 2, ;
		Left = 144, ;
		Name = "oVector2", ;
		Top = -136, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oVector3' AS fglvector WITH ;
		Height = 2, ;
		Left = 144, ;
		Name = "oVector3", ;
		Top = -100, ;
		Width = 7
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oVector4' AS fglvector WITH ;
		Height = 0, ;
		Left = 152, ;
		Name = "oVector4", ;
		Top = -92, ;
		Width = 0
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oVisual' AS fglvisual WITH ;
		Height = 2, ;
		Left = 12, ;
		Name = "oVisual", ;
		Top = -270, ;
		Width = 35
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />
	
	PROCEDURE errmsg
		LPARAMETERS tvMsg
		
		LOCAL lcMsg
		m.lcMsg = ""
		
		DO CASE
		CASE VARTYPE(m.tvMsg)="O"
		
		    LOCAL lcLineContents
		    m.lcLineContents = ""
		
		    LOCAL laStack(1), lnStack
		    m.lnStack = ASTACKINFO(laStack)
		    IF m.lnStack > 2
		        m.lcLineContents = m.laStack[lnStack - 2, 6]
		    ENDIF
		
		    m.lcMsg = ;
		        m.tvMsg.Message + ;
		        RTRIM(" " + NVL(m.tvMsg.Details,"")) + ;
		        RTRIM(" " + NVL(m.tvMsg.UserValue,"")) + ;
		        CHR(13) + "Procedure: " + m.tvMsg.Procedure + ;
		        CHR(13) + "LineContents: " + m.lcLineContents
		
		CASE VARTYPE(m.tvMsg)="C"
		    m.lcMsg = ALLTRIM(m.tvMsg)
		
		ENDCASE
		
		IF EMPTY(m.lcMsg) = .F.
		    IF INLIST(Application.StartMode, 2, 3, 5)
		        WAIT WINDOW (m.lcMsg) NOWAIT
		    ELSE
		        MESSAGEBOX(m.lcMsg, 0+16, This.Class + " (" + This.ClassLibrary + ")" )
		    ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE fglc_create
		IF EMPTY(This.hSceneInit)=.F.
			RETURN .T.
		ENDIF
		
		This.hSceneInit = This.oScene.fgl_create()
		IF EMPTY(This.hSceneInit)
			RETURN .F.
		ENDIF
		This.oScene.MSAAMode = This.MSAAMode
		This.oScene.loadGL(Thisform.HWnd)
		This.oViewport.hFGL = This.hScene()
		
		IF DODEFAULT()=.F.
			RETURN .F.
		ENDIF
		
		This.aModels = NEWOBJECT("Collection")
		
		This.NewObject("oActPoint", "fglc.fglc_actpoint")
		This.hActPointsColliderInit =  This.oActPointsCollider.fgl_create(This.hScene())
		This.hCollideInfoInit = This.oCollideInfo.fgl_create(This.hScene())
		
	ENDPROC

	PROCEDURE fglc_release
		DODEFAULT()
		This.oScene.fgl_release(This.hSceneInit)
		This.oScene.hFGL=(0)
		
		This.oActPointsCollider.fgl_release(This.hActPointsColliderInit)
		This.oActPointsCollider.hFGL=(0)
		This.oCollideInfo.fgl_release(This.hCollideInfoInit)
		This.oCollideInfo.hFGL=(0)
		
		IF VARTYPE(This.aModels)="O"
			LOCAL lhModel
			FOR EACH lhModel IN This.aModels
				This.oModel.fgl_release(lhModel)
			ENDFOR
		ENDIF
		This.aModels = .F.
		This.oModel.hFGL=(0)
		
		This.oGetHandler.hFGL=(0)
		
	ENDPROC

	PROCEDURE gethandler
		LPARAMETERS thNode, toObj
		
		LOCAL lhNode, lcObjName
		lhNode = m.thNode
		DO WHILE .T.
			IF EMPTY(lhNode)
				RETURN 0
			ENDIF
			This.oGetHandler.hFGL = lhNode
			lcObjName = NVL(This.oGetHandler.getProp("fglc_name"),"")
			IF EMPTY(lcObjName)=.F.
				IF PEMSTATUS(This, lcObjName, 5)=.F. AND TYPE("This."+lcObjName)<>"O"
					RETURN 0
				ENDIF
				toObj = This.&lcObjName
				RETURN lhNode
			ENDIF
			lhNode = EVL(This.oGetHandler.hParent,0)
		ENDDO
		
	ENDPROC

	PROCEDURE loadmodel
		LPARAMETERS tcModelPath, tlSilent
		
		LOCAL lcModelPath, lhSaveModel
		lcModelPath = EVL(tcModelPath,"")
		
		lhSaveModel = This.oModel.hFGL
		
		IF EMPTY(lcModelPath)
			RETURN 0
		ENDIF
		
		IF This.aModels.getKey(lcModelPath)=0
			IF FILE(lcModelPath)=.F.
				RETURN 0
			ENDIF
			
			LOCAL lhModel
			lhModel = This.oModel.fgl_create(This.hScene())
			IF EMPTY(lhModel)
				This.oModel.hFGL = lhSaveModel
				RETURN 0
			ENDIF
		    
		    LOCAL loErr
		    loErr = .F.
			TRY
		        This.oModel.loadData(lcModelPath)
		    CATCH TO loErr
		        IF m.tlSilent = .F.
		            This.errMsg(m.loErr)
		        ENDIF
		    ENDTRY
		    IF VARTYPE(loErr) = "O"
		        This.oModel.fgl_release()
		        This.oModel.hFGL = lhSaveModel
		        RETURN 0
		    ENDIF
		    
			This.oModel.duplicateMode = 2 &&fglDUPLICATE_INSTANCE
			This.aModels.Add(lhModel, lcModelPath)
		ENDIF
		
		This.oModel.hFGL = lhSaveModel
		
		RETURN This.aModels.Item(lcModelPath)
		
	ENDPROC

	PROCEDURE lockevents
		LPARAMETERS tlOnOff
		
		IF m.tlOnOff=.T. AND This.lockEventsLevel = 0
			This.lockEventsState[1,1] = _VFP.AutoYield
			_VFP.AutoYield = .F.
		ENDIF
		
		IF m.tlOnOff=.F. AND This.lockEventsLevel = 1
			_VFP.AutoYield = This.lockEventsState[1,1]
		ENDIF
		
		This.lockEventsLevel = MAX(This.lockEventsLevel + IIF(m.tlOnOff, 1, -1),0)
		
	ENDPROC

	PROCEDURE unloadmodel
		LPARAMETERS tcModelPathOrHFGL
		
		LOCAL lcModelPathOrHFGL, lhSaveModel
		lcModelPathOrHFGL = EVL(m.tcModelPathOrHFGL,"")
		lhSaveModel = This.oModel.hFGL
		
		TRY
		    LOCAL lnModelIndex
		    lnModelIndex = 0
		    DO CASE
		    CASE EMPTY(m.lcModelPathOrHFGL)
		    CASE VARTYPE(lcModelPathOrHFGL) = "C"
		        lnModelIndex = This.aModels.getKey(lcModelPathOrHFGL)
		    CASE VARTYPE(lcModelPathOrHFGL) = "N"
		        LOCAL liModel
		        FOR liModel = 1 TO This.aModels.Count
		           IF This.aModels.Item(liModel) = lcModelPathOrHFGL
		               lnModelIndex = liModel
		               EXIT
		           ENDIF
		        ENDFOR
		    ENDCASE
		    
		    IF lnModelIndex = 0
		        EXIT
		    ENDIF
		
		    This.oModel.hFGL = This.aModels.Item(lnModelIndex)
		    This.oModel.fgl_release()
		
		    This.aModels.Remove(lnModelIndex)
		
		FINALLY
		    This.oModel.hFGL = lhSaveModel
		ENDTRY
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fglc_obj AS custom 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: click		&& Occurs when the user presses and then releases a mouse button over an object or when you programmatically trigger the event.
		*m: contextmenu
		*m: contextmenu_define
		*m: dblclick		&& Occurs when the user presses and releases the left (primary) mouse button twice in quick succession.
		*m: fglc_bind
		*m: fglc_class_assign
		*m: fglc_create
		*m: fglc_define
		*m: fglc_release
		*m: gotfocus		&& Occurs when an object receives the focus, either by user action or through code.
		*m: hnode
		*m: hscene
		*m: isenabled_access
		*m: isenabled_assign
		*m: isfocused_access
		*m: isfocused_assign
		*m: ismoveable
		*m: isselected_access
		*m: isselected_assign
		*m: isvisible_access
		*m: isvisible_assign
		*m: loadmodel
		*m: lostfocus		&& Occurs when an object loses the focus.
		*m: maxsizex_access
		*m: maxsizex_assign
		*m: maxsizey_access
		*m: maxsizey_assign
		*m: maxsizez_access
		*m: maxsizez_assign
		*m: minsizex_access
		*m: minsizex_assign
		*m: minsizey_access
		*m: minsizey_assign
		*m: minsizez_access
		*m: minsizez_assign
		*m: mousedown		&& Occurs when the user presses the mouse button.
		*m: mouseenter		&& Occurs when the user moves the mouse into an object.
		*m: mouseleave		&& Occurs when the user moves the mouse out of an object.
		*m: mousemove		&& Occurs when the user moves the mouse over an object.
		*m: mouseup		&& Occurs when the user releases the mouse button.
		*m: mousewheel		&& Occurs when the user moves the wheel of the mouse when over an object.
		*m: move		&& Moves an object.
		*m: nmoveconstraint_access
		*m: nmoveconstraint_assign
		*m: resize		&& Occurs when an object is resized.
		*m: rightclick		&& Occurs when the user presses and then releases the right (secondary) mouse button over a control.
		*m: rotate
		*m: set_omain
		*m: showselected
		*p: ainsts		&& Instances
		*p: fglc_class
		*p: isenabled
		*p: isfocused
		*p: isselected
		*p: isvisible
		*p: maxsizex
		*p: maxsizey
		*p: maxsizez
		*p: minsizex
		*p: minsizey
		*p: minsizez
		*p: mousepointer		&& Specifies the shape of the mouse pointer when the mouse is over a particular part of an object at run time.
		*p: nmoveconstraint
		*p: omain
	*</DefinedPropArrayMethod>

	PROTECTED ainsts
	*<PropValue>
		ainsts = 
		fglc_class = ("fglc_obj")
		Height = 24
		isenabled = .F.
		isfocused = .F.
		isselected = .F.
		isvisible = .F.
		maxsizex = 0
		maxsizey = 0
		maxsizez = 0
		minsizex = 0
		minsizey = 0
		minsizez = 0
		mousepointer = 0
		Name = "fglc_obj"
		nmoveconstraint = 0
		omain = 
		Width = 37
	*</PropValue>
	
	PROCEDURE click		&& Occurs when the user presses and then releases a mouse button over an object or when you programmatically trigger the event.
		LPARAMETERS oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE contextmenu
		LPARAMETERS oPickInfo
		
		LOCAL lcMenuName
		lcMenuName = This.contextmenu_define(m.oPickInfo)
		
		IF VARTYPE(lcMenuName)<>"C" OR EMPTY(lcMenuName)
			RETURN .F.
		ENDIF
		
		IF CNTBAR(lcMenuName)=0
			RETURN .F.
		ENDIF
		
		PRIVATE poThis, poThisform
		poThis = This
		poThisform = Thisform
		ACTIVATE POPUP &lcMenuName
		poThis = .F.
		poThisform = .F.
		
	ENDPROC

	PROCEDURE contextmenu_define
		LPARAMETERS oPickInfo
		
		LOCAL lcWindow, lcMenuName, lnCntBar
		lcWindow = Thisform.Name
		lcMenuName = Thisform.Name+"_context"
		
		DEFINE POPUP &lcMenuName FROM MROW(lcWindow), MCOL(lcWindow) IN &lcWindow MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		RETURN lcMenuName
		
	ENDPROC

	PROCEDURE dblclick		&& Occurs when the user presses and releases the left (primary) mouse button twice in quick succession.
		LPARAMETERS oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE Destroy
		IF VARTYPE(This.aInsts)="O"
			LOCAL lhNode
			DO WHILE This.aInsts.Count<>0
				lhNode = This.aInsts.Item(1)
				This.aInsts.Remove(1)
				This.fglc_release(lhNode)
			ENDDO
		ENDIF
		This.aInsts = .F.
		
	ENDPROC

	PROCEDURE fglc_bind
		LPARAMETERS thNode
		
		This.oNode.hFGL=(m.thNode)
		
	ENDPROC

	HIDDEN PROCEDURE fglc_class_assign
		LPARAMETERS vNewVal
		ERROR 1533
		
	ENDPROC

	PROCEDURE fglc_create
		LOCAL lhNode
		lhNode = This.oNode.fgl_create(This.hScene())
		IF EMPTY(lhNode)=.T.
			RETURN .F.
		ENDIF
		This.aInsts.add(lhNode, TRANSFORM(lhNode))
		
		This.oNode.copy(This.aInsts.Item(1))
		This.fglc_bind(lhNode)
		
		
		
	ENDPROC

	PROCEDURE fglc_define
		This.NewObject("oNode", "fgl.fglNode")
		
		LOCAL lhNode
		lhNode = This.oNode.fgl_create(This.hScene())
		IF EMPTY(lhNode)=.T.
			RETURN .F.
		ENDIF
		This.aInsts.add(lhNode, TRANSFORM(lhNode))
		
		This.oNode.setProp("fglc_name", STRTRAN(SYS(1272, This), SYS(1272,This.oMain)+"."))
		
		This.isSelected = .F.
		This.nMoveConstraint = 0
		
	ENDPROC

	PROCEDURE fglc_release
		LPARAMETERS thNode
		
		LOCAL lnInst
		lnInst = This.aInsts.getKey(TRANSFORM(m.thNode))
		IF lnInst<>0
			This.aInsts.Remove(lnInst)
		ENDIF
		
		This.fglc_bind(m.thNode)
		This.oNode.fgl_release()
		This.fglc_bind(0)
		
	ENDPROC

	PROCEDURE gotfocus		&& Occurs when an object receives the focus, either by user action or through code.
		LPARAMETERS nButton, nShift
		
		This.isFocused = .T.
		
	ENDPROC

	PROCEDURE hnode
		RETURN This.oNode.hFGL
		
	ENDPROC

	PROCEDURE hscene
		RETURN This.oMain.oScene.hFGL
		
	ENDPROC

	PROCEDURE Init
		IF This.set_oMain()=.F.
			RETURN .F.
		ENDIF
		This.aInsts = NEWOBJECT("Collection")
		
		This.fglc_define()
		
	ENDPROC

	HIDDEN PROCEDURE isenabled_access
		RETURN This.oNode.isEnabled
		
	ENDPROC

	HIDDEN PROCEDURE isenabled_assign
		LPARAMETERS vNewVal
		
		This.oNode.isEnabled = m.vNewVal
		
	ENDPROC

	HIDDEN PROCEDURE isfocused_access
		RETURN NVL(This.oNode.getProp("isFocused"),.F.)
		
	ENDPROC

	HIDDEN PROCEDURE isfocused_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("isFocused",m.vNewVal)
		
	ENDPROC

	PROCEDURE ismoveable
		RETURN EMPTY(This.nMoveConstraint)=.F.
		
	ENDPROC

	HIDDEN PROCEDURE isselected_access
		RETURN NVL(This.oNode.getProp("isSelected"),0)
		
	ENDPROC

	HIDDEN PROCEDURE isselected_assign
		LPARAMETERS vNewVal
		
		This.oNode.setProp("isSelected", m.vNewVal)
		This.showSelected(m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE isvisible_access
		RETURN This.oNode.isVisible
		
	ENDPROC

	HIDDEN PROCEDURE isvisible_assign
		LPARAMETERS vNewVal
		This.oNode.isVisible = m.vNewVal
		
	ENDPROC

	PROCEDURE loadmodel
		LPARAMETERS tcModelPath
		
		RETURN This.oMain.loadModel(m.tcModelPath)
		
	ENDPROC

	PROCEDURE lostfocus		&& Occurs when an object loses the focus.
		LPARAMETERS nButton, nShift
		
		This.isFocused = .F.
		
	ENDPROC

	HIDDEN PROCEDURE maxsizex_access
		RETURN This.oNode.getProp("maxSizeX")
		
	ENDPROC

	HIDDEN PROCEDURE maxsizex_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal < This.minSizeX
			THROW "maxSizeX must be greater or equal to minSizeX"
		ENDIF
		
		This.oNode.setProp("maxSizeX", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE maxsizey_access
		RETURN This.oNode.getProp("maxSizeY")
		
	ENDPROC

	HIDDEN PROCEDURE maxsizey_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal < This.minSizeY
			THROW "maxSizeY must be greater or equal to minSizeY"
		ENDIF
		
		This.oNode.setProp("maxSizeXY", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE maxsizez_access
		RETURN This.oNode.getProp("maxSizeZ")
		
	ENDPROC

	HIDDEN PROCEDURE maxsizez_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal < This.minSizeZ
			THROW "maxSizeZ must be greater or equal to minSizeZ"
		ENDIF
		
		This.oNode.setProp("maxSizeZ", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE minsizex_access
		RETURN This.oNode.getProp("minSizeX")
		
	ENDPROC

	HIDDEN PROCEDURE minsizex_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal > This.maxSizeX
			THROW "minSizeX must be less or equal to maxSizeX"
		ENDIF
		
		This.oNode.setProp("minSizeX", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE minsizey_access
		RETURN This.oNode.getProp("minSizeY")
		
	ENDPROC

	HIDDEN PROCEDURE minsizey_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal > This.maxSizeY
			THROW "minSizeY must be less or equal to maxSizeY"
		ENDIF
		
		This.oNode.setProp("minSizeY", m.vNewVal)
		
	ENDPROC

	HIDDEN PROCEDURE minsizez_access
		RETURN This.oNode.getProp("minSizeZ")
		
	ENDPROC

	HIDDEN PROCEDURE minsizez_assign
		LPARAMETERS vNewVal
		
		IF NVL(m.vNewVal,0)<0
			THROW "Negative used as argument."
		ENDIF
		
		IF m.vNewVal > This.maxSizeZ
			THROW "minSizeZ must be less or equal to maxSizeZ"
		ENDIF
		
		This.oNode.setProp("minSizeZ", m.vNewVal)
		
	ENDPROC

	PROCEDURE mousedown		&& Occurs when the user presses the mouse button.
		LPARAMETERS nButton, nShift, oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE mouseenter		&& Occurs when the user moves the mouse into an object.
		LPARAMETERS nButton, nShift, oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE mouseleave		&& Occurs when the user moves the mouse out of an object.
		LPARAMETERS nButton, nShift, oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE mousemove		&& Occurs when the user moves the mouse over an object.
		LPARAMETERS nButton, nShift, oPickInfo
		
		IF INLIST(m.nButton,1) AND This.isMoveable()
			LOCAL loMove
			loMove = oPickInfo.getMove(This.hNode(), This.nMoveConstraint)
			This.move(loMove.x, loMove.y, loMove.z)
			This.oMain.oScene.render()
			RETURN .T.
		ENDIF
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE mouseup		&& Occurs when the user releases the mouse button.
		LPARAMETERS nButton, nShift, oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE mousewheel		&& Occurs when the user moves the wheel of the mouse when over an object.
		LPARAMETERS nDirection, nShift, oPickInfo
		
		RETURN .F.
		
	ENDPROC

	PROCEDURE move		&& Moves an object.
		LPARAMETERS tnX, tnY, tnZ
		
		This.oMain.lockEvents(.T.)
		
		This.oNode.moveDir(m.tnX, m.tnY, m.tnZ)
		
		This.oMain.lockEvents(.F.)
		
	ENDPROC

	HIDDEN PROCEDURE nmoveconstraint_access
		RETURN NVL(This.oNode.getProp("nMoveConstraint"), 0)
		
	ENDPROC

	HIDDEN PROCEDURE nmoveconstraint_assign
		LPARAMETERS vNewVal
		This.oNode.setProp("nMoveConstraint", m.vNewVal)
		
	ENDPROC

	PROCEDURE resize		&& Occurs when an object is resized.
		This.oNode.calcBounds()
		
	ENDPROC

	PROCEDURE rightclick		&& Occurs when the user presses and then releases the right (secondary) mouse button over a control.
		LPARAMETERS oPickInfo
		
		RETURN This.contextmenu(m.oPickInfo)
		
	ENDPROC

	PROCEDURE rotate
		LPARAMETERS tnX, tnY, tnZ, tnCx, tnCy, tnCz
		
		This.oNode.RotateBy(m.tnX, m.tnY, m.tnZ, m.tnCx, m.tnCy, m.tnCz)
		
	ENDPROC

	PROCEDURE set_omain
		IF VARTYPE(This.oMain)="O"
			RETURN .T.
		ENDIF
		
		LOCAL loMain, loErr
		loMain = This
		DO WHILE .T.
		
			IF PEMSTATUS(loMain, "fglc_class", 5)
				IF loMain.fglc_class == "fglc_main"
					This.oMain = loMain
					RETURN This.oMain.set_oMain()
				ENDIF
			ENDIF
			
			loErr = .F.
			TRY 
				loMain = loMain.Parent
			CATCH TO loErr
			ENDTRY
			IF VARTYPE(loErr)="O"
				THROW "Parent of " + This.Name + " must be an instance of 'fglc_main' class"
				RETURN .F.
			ENDIF
		ENDDO
		
	ENDPROC

	PROCEDURE showselected
		LPARAMETERS tlIsSelected
		
		IF m.tlIsSelected
			This.oNode.bbox.isVisible = .T.
		ELSE
			This.oNode.bbox.isVisible = .F.
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS fglc_viewport AS container 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oViewport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oCam" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oPickInfo" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: backcolor_assign
		*m: contextmenu
		*m: contextmenu_define
		*m: fglc_class_assign
		*m: fglc_create
		*m: fglc_release
		*m: hscene
		*m: nmousedx
		*m: nmousedy
		*m: set_omain
		*p: fglc_class
		*p: hactiveobj
		*p: hcaminit
		*p: hmousedownobj
		*p: hmousemoveobj
		*p: hpickinfoinit
		*p: hviewportinit
		*p: ismousemoved
		*p: nmousedownpgx
		*p: nmousedownpgy
		*p: nmousedownpgz
		*p: nmousedownpx
		*p: nmousedownpy
		*p: nmousedownpz
		*p: nmousedownx
		*p: nmousedowny
		*p: nmousex0
		*p: nmousex1
		*p: nmousey0
		*p: nmousey1
		*p: omain
		*p: savemousepointer
	*</DefinedPropArrayMethod>

	HIDDEN hcaminit,hpickinfoinit,hviewportinit
	PROTECTED hmousedownobj,hmousemoveobj,ismousemoved,omain,savemousepointer
	*<PropValue>
		fglc_class = ("fglc_viewport")
		hactiveobj = 0
		hcaminit = 0
		Height = 200
		hmousedownobj = 0
		hmousemoveobj = 0
		hpickinfoinit = 0
		hviewportinit = 0
		ismousemoved = .F.
		Name = "fglc_viewport"
		nmousedownpgx = 0
		nmousedownpgy = 0
		nmousedownpgz = 0
		nmousedownpx = 0
		nmousedownpy = 0
		nmousedownpz = 0
		nmousedownx = 0
		nmousedowny = 0
		nmousex0 = 0
		nmousex1 = 0
		nmousey0 = 0
		nmousey1 = 0
		omain = 
		savemousepointer = (NULL)
		Width = 200
	*</PropValue>

	ADD OBJECT 'oCam' AS fglcam WITH ;
		Height = 8, ;
		Left = 84, ;
		Name = "oCam", ;
		Top = -192, ;
		Width = 1
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oPickInfo' AS fglpickinfo WITH ;
		Height = 2, ;
		Left = 120, ;
		Name = "oPickInfo", ;
		Top = -192, ;
		Width = 10
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />

	ADD OBJECT 'oViewport' AS fglviewport WITH ;
		Height = 2, ;
		Left = 36, ;
		Name = "oViewport", ;
		Top = -204, ;
		Width = 10
		*< END OBJECT: ClassLib="fgl.vcx" BaseClass="custom" />
	
	HIDDEN PROCEDURE backcolor_assign
		LPARAMETERS vNewVal
		
		This.oViewport.backColor = m.vNewVal
		
	ENDPROC

	PROCEDURE Click
		
		LOCAL llRes
		llRes=.F.
		
		LOCAL m.nXCoord,m.nYCoord
		m.nXCoord = MCOL(0,3)
		m.nYCoord = MROW(0,3)
		
		LOCAL lhObj, loObj
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObj = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		IF EMPTY(lhObj)=.F.
			loObj.fglc_bind(lhObj)
			llRes = loObj.click(This.oPickInfo)
		ENDIF
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE contextmenu
		LOCAL lcMenuName
		lcMenuName = This.contextmenu_define()
		
		IF VARTYPE(lcMenuName)<>"C" OR EMPTY(lcMenuName)
			RETURN
		ENDIF
		
		IF CNTBAR(lcMenuName)=0
			RETURN
		ENDIF
		
		PRIVATE poThis, poThisform
		poThis = This
		poThisform = Thisform
		ACTIVATE POPUP &lcMenuName
		poThis = .F.
		poThisform = .F.
		
	ENDPROC

	PROCEDURE contextmenu_define
		LOCAL lcWindow, lcMenuName, lnCntBar
		lcWindow = Thisform.Name
		lcMenuName = Thisform.Name+"_context"
		
		DEFINE POPUP &lcMenuName FROM MROW(lcWindow), MCOL(lcWindow) IN &lcWindow MARGIN RELATIVE SHORTCUT FONT 'Segoe UI', 10
		
		RETURN lcMenuName
		
	ENDPROC

	PROCEDURE DblClick
		
		LOCAL llRes
		llRes=.F.
		
		LOCAL m.nXCoord,m.nYCoord
		m.nXCoord = MCOL(0,3)
		m.nYCoord = MROW(0,3)
		
		LOCAL lhObj, loObj
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObj = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		IF EMPTY(lhObj)=.F.
			loObj.fglc_bind(lhObj)
			llRes = loObj.dblClick(This.oPickInfo)
		ENDIF
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE Destroy
		This.fglc_release()
		
	ENDPROC

	HIDDEN PROCEDURE fglc_class_assign
		LPARAMETERS vNewVal
		ERROR 1533
		
	ENDPROC

	PROTECTED PROCEDURE fglc_create
		
		IF EMPTY(This.oViewPort.hFGL)=.T.
			This.hViewportInit = This.oViewPort.fgl_create(This.hScene())
			IF EMPTY(This.hViewportInit)
				RETURN .F.
			ENDIF
		ENDIF
		
		IF EMPTY(This.oCam.hFGL)
			This.hCamInit = This.oCam.fgl_create(This.hScene())
			IF EMPTY(This.hCamInit)
				RETURN .F.
			ENDIF
		ENDIF
		This.oViewport.hCam = This.oCam.hFGL
		
		This.backColor = This.backColor
		This.resize()
		
		IF EMPTY(This.oPickInfo.hFGL)
			This.hPickInfoInit = This.oPickInfo.fgl_create(This.hScene())
			IF EMPTY(This.hPickInfoInit)
				RETURN .F.
			ENDIF
		ENDIF
		This.oPickInfo.hViewport = This.oViewport.hFGL
		
	ENDPROC

	PROTECTED PROCEDURE fglc_release
		This.oViewport.fgl_release(This.hViewportInit)
		This.oViewport.hFGL=(0)
		
		This.oCam.fgl_release(This.hCamInit)
		This.oCam.hFGL=(0)
		
		This.oPickInfo.fgl_release(This.hPickInfoInit)
		This.oPickInfo.hFGL=(0)
		
	ENDPROC

	PROCEDURE hscene
		RETURN This.oMain.oScene.hFGL
		
	ENDPROC

	PROCEDURE Init
		IF This.set_oMain()=.F.
			RETURN .F.
		ENDIF
		
		
	ENDPROC

	PROCEDURE MouseDown
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		NODEFAULT
		
		This.oMain.lockEvents(.T.)
		*******************************************
		
		LOCAL llRes
		llRes=.F.
		
		This.nMouseX0 = m.nXCoord
		This.nMouseY0 = m.nYCoord
		This.nMouseX1 = m.nXCoord
		This.nMouseY1 = m.nYCoord
		
		This.nMouseDownX = m.nXCoord
		This.nMouseDownY = m.nYCoord
		
		This.isMouseMoved = .F.
		
		IF EMPTY( This.oPickInfo.pick(m.nXCoord,m.nYCoord) ) =.F.
			This.nMouseDownPx = This.oPickInfo.p.x
			This.nMouseDownPy = This.oPickInfo.p.y
			This.nMouseDownPz = This.oPickInfo.p.z
			This.nMouseDownPGx = This.oPickInfo.pg.x
			This.nMouseDownPGy = This.oPickInfo.pg.y
			This.nMouseDownPGz = This.oPickInfo.pg.z
		ELSE
			This.nMouseDownPx = 0
			This.nMouseDownPy = 0
			This.nMouseDownPz = 0
		ENDIF
		
		LOCAL lhObj, loObj
		lhObj = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		IF EMPTY(lhObj)=.F.
			This.hMouseDownObj = lhObj
			loObj.fglc_bind(lhObj)
			llRes = loObj.mouseDown(m.nButton, m.nShift, This.oPickInfo)
		ELSE
			This.hMouseDownObj = 0
		ENDIF
		
		IF This.hActiveObj<>lhObj AND EMPTY(This.hActiveObj)=.F.
			LOCAL loActiveObjPrev, lhSaveActiveObj
			IF This.oMain.getHandler(This.hActiveObj, @loActiveObjPrev)=This.hActiveObj
				lhSaveActiveObj = loActiveObjPrev.hNode()
				loActiveObjPrev.fglc_bind(This.hActiveObj)
				loActiveObjPrev.lostFocus(m.nButton, m.nShift)
				loActiveObjPrev.fglc_bind(lhSaveActiveObj)
			ENDIF
		
		ENDIF
		This.hActiveObj = lhObj
		IF EMPTY(This.hActiveObj)=.F.
			loObj.gotFocus(m.nButton, m.nShift)
		ENDIF
		
		*******************************************
		This.oMain.lockEvents(.F.)
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE MouseMove
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		NODEFAULT
		LOCAL llRes
		llRes=.F.
		
		This.oMain.lockEvents(.T.)
		*******************************************
		
		IF EMPTY(m.nButton)
			This.hMouseDownObj = 0
		ENDIF
		
		This.nMouseX0 = This.nMouseX1
		This.nMouseY0 = This.nMouseY1
		This.nMouseX1 = m.nXCoord
		This.nMouseY1 = m.nYCoord
		
		This.isMouseMoved = .T.
		
		LOCAL lhObj, loObj
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObj = This.oMain.getHandler(EVL(This.hMouseDownObj, This.oPickInfo.hPickedNode), @loObj)
		IF EMPTY(lhObj)=.F.
			DO CASE
			 CASE This.hMouseMoveObj = lhObj
				loObj.fglc_bind(lhObj)
				llRes = loObj.mouseMove(m.nButton, m.nShift, This.oPickInfo)
			 CASE EMPTY(m.nButton) OR This.hMouseDownObj = lhObj
				IF EMPTY(This.hMouseMoveObj)=.F.
					LOCAL loMoveObj
					IF This.oMain.getHandler(This.hMouseMoveObj, @loMoveObj)=This.hMouseMoveObj
						loMoveObj.fglc_bind(This.hMouseMoveObj)
						loMoveObj.mouseLeave(m.nButton, m.nShift, This.oPickInfo)
					ENDIF
				ENDIF
				
				This.hMouseMoveObj = lhObj
				loObj.fglc_bind(lhObj)
				loObj.mouseEnter(m.nButton, m.nShift, This.oPickInfo)
				llRes = loObj.mouseMove(m.nButton, m.nShift, This.oPickInfo)
			ENDCASE
			IF ISNULL(This.SaveMousePointer)=.T.
				This.SaveMousePointer = This.MousePointer
			ENDIF
			This.MousePointer = NVL(EVL(loObj.MousePointer, This.SaveMousePointer),0)
		ELSE
			IF ISNULL(This.SaveMousePointer)=.F.
				This.MousePointer = This.SaveMousePointer
				This.SaveMousePointer = NULL
			ENDIF
			This.hMouseMoveObj = 0
		ENDIF
		*******************************************
		This.oMain.lockEvents(.F.)
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		
		LOCAL llRes
		llRes=.F.
		
		*!*	This.nMouseX0 = This.nMouseX1
		*!*	This.nMouseY0 = This.nMouseY1
		This.nMouseX0 = m.nXCoord
		This.nMouseY0 = m.nYCoord
		This.nMouseX1 = m.nXCoord
		This.nMouseY1 = m.nYCoord
		
		
		This.oMain.lockEvents(.T.)
		*******************************************
		
		LOCAL lhObj, loObj, lhObjReal
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObjReal = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		lhObj = This.oMain.getHandler(This.hMouseDownObj, @loObj)
		IF EMPTY(lhObj)=.F. 
			loObj.fglc_bind(lhObj)
			llRes = loObj.mouseUp(m.nButton, m.nShift, This.oPickInfo)
		ENDIF
		
		*******************************************
		This.oMain.lockEvents(.F.)
		
		IF lhObj<>lhObjReal
			NODEFAULT &&skip rightClick event
			This.hMouseDownObj = 0
			RETURN llRes
		ENDIF
		
		IF This.isMouseMoved = .T.
			NODEFAULT &&skip rightClick event
			This.hMouseDownObj = 0
			RETURN llRes
		ENDIF
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE MouseWheel
		LPARAMETERS nDirection, nShift, nXCoord, nYCoord
		
		LOCAL llRes
		llRes=.F.
		
		This.oMain.lockEvents(.T.)
		*******************************************
		
		LOCAL lhObj, loObj
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObj = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		IF EMPTY(lhObj)=.F.
			loObj.fglc_bind(lhObj)
			llRes = loObj.mouseWheel(m.nDirection, m.nShift, This.oPickInfo)
		ENDIF
		
		*******************************************
		This.oMain.lockEvents(.F.)
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE Moved
		This.oViewport.Move(This.Left, This.Top, This.Width, This.Height)
		
	ENDPROC

	PROCEDURE nmousedx
		RETURN This.nMouseX1 - This.nMouseX0
		
	ENDPROC

	PROCEDURE nmousedy
		RETURN This.nMouseY1 - This.nMouseY0
		
	ENDPROC

	PROCEDURE Resize
		This.oViewport.Move(This.Left, This.Top, This.Width, This.Height)
		
	ENDPROC

	PROCEDURE RightClick
		
		LOCAL llRes
		llRes=.F.
		
		LOCAL m.nXCoord,m.nYCoord
		m.nXCoord = MCOL(0,3)
		m.nYCoord = MROW(0,3)
		
		LOCAL lhObj, loObj
		This.oPickInfo.pick(m.nXCoord,m.nYCoord)
		lhObj = This.oMain.getHandler(This.oPickInfo.hPickedNode, @loObj)
		IF EMPTY(lhObj)=.F. AND This.hMouseDownObj = lhObj
			loObj.fglc_bind(lhObj)
			llRes = loObj.rightClick(This.oPickInfo)
		ENDIF
		This.hMouseDownObj = 0
		
		IF EMPTY(lhObj)
			This.contextmenu()
		ENDIF
		
		RETURN llRes
		
	ENDPROC

	PROCEDURE set_omain
		IF VARTYPE(This.oMain)="O"
			RETURN .T.
		ENDIF
		
		LOCAL loMain, loErr
		loMain = This
		DO WHILE .T.
			
			IF PEMSTATUS(loMain, "fglc_class", 5)
				IF loMain.fglc_class == "fglc_main"
					This.oMain = loMain
					IF This=This.oMain
						RETURN This.fglc_create()
					ELSE
						IF This.oMain.set_oMain()=.F.
							RETURN .F.
						ENDIF
						RETURN This.fglc_create()
					ENDIF
				ENDIF
			ENDIF
		
			loErr = .F.
			TRY 
				loMain = loMain.Parent
			CATCH TO loErr
			ENDTRY
			IF VARTYPE(loErr)="O"
				THROW "Parent of " + This.Name + " must be an instance of 'fglc_main' class"
				RETURN .F.
			ENDIF
		ENDDO
		
	ENDPROC

	PROCEDURE oPickInfo.getmove
		LPARAMETERS thNode, tnConstraint, tnXCoord1, tnYCoord1, tnXCoord2, tnYCoord2
		
		IF VARTYPE(m.tnXCoord1)='L'
			RETURN DODEFAULT(m.thNode, m.tnConstraint, This.Parent.nMouseX0, This.Parent.nMouseY0, This.Parent.nMouseX1, This.Parent.nMouseY1)
		ELSE
			RETURN DODEFAULT(m.thNode, m.tnConstraint, m.tnXCoord1, m.tnYCoord1, m.tnXCoord2, m.tnYCoord2)
		ENDIF
		
	ENDPROC

ENDDEFINE
